# ðŸ§© ChivDB â€” The Multipurpose Database Abstraction Layer

**ChivDB** (short for *Chivalrous Database*) is a **multi-engine database unification layer** for Java.  
It provides a **single, type-safe API** across both **relational** and **document** databases, empowering developers to write expressive, vendor-neutral data access logic.

> Think of ChivDB as a Swiss-army knife for database integration â€” one consistent model, multiple back-ends, no dialect headaches.

### âš™ï¸ Installation (Gradle + Kotlin DSL)
Currently, ChivDB is still in experimental phases.
as of now, the only way to actually have ChivDB, is by compiling it in your own IDE/IDEA and work with its flow.
We have no estimation on when this will be officially published.

---

## âœ¨ Key Features

- **Unified API** â€” Query SQL or NoSQL engines with one fluent syntax.
- **Type Safety** â€” Full generic typing from field definitions to result mapping.
- **Automatic Objectification** â€” Convert rows or documents directly into POJOs or records.
- **Multi-Engine Architecture** â€” Plug in jOOQ (Postgres, MySQL, SQLite), MongoDB, RethinkDB, and more.
- **Clean Encapsulation** â€” No driver leakage; engine specifics are completely hidden.
- **Declarative Conditions** â€” Build expressive, composable predicates (`and`, `or`, `in`, `regex`, `arrayContains`, etc.).
- **ServiceLoader Bootstrapping** â€” Engines self-register through the JVMâ€™s SPI mechanism.

---

## ðŸ§  Concept Overview

ChivDB abstracts the notion of *data access* rather than *query dialects*.

Every engine implements two canonical interfaces:

- `RelationalApi` â€” for table-like operations (`SELECT`, `INSERT`, `UPDATE`, `DELETE`).
- `DocumentApi` â€” for JSON/BSON document stores (e.g. MongoDB).

These are opened through a single `DbHandle` that is produced by the static entry point `UnifiedDB.init(cfg)`.

```java
var cfg = DbConfig.builder()
    .kind(EngineKind.POSTGRES)
    .uri("jdbc:postgresql://localhost:5432/game")
    .username("admin")
    .password("secret")
    .build();

try (var db = UnifiedDB.init(cfg)) {
    db.relational().ifPresent(r -> {
        var id = UUID.fromString("a6bbd99a-0a8a-48bb-84cb-8df1b9a76420");
        var player = r.fetch("players")
            .where(Conditions.eq(Fields.uuid("id"), id))
            .oneAs(Player.class);
        System.out.println(player);
    });
}
```

## ðŸ—ï¸ Architecture
core/
 â”œâ”€â”€ ChivField --------------------// Typed field abstraction
 â”œâ”€â”€ ChivCondition --------------// AST root (Atom, Junction, Not)
 â”œâ”€â”€ Conditions ------------------// Static builders (eq, gt, regex, in, etc.)
 â”œâ”€â”€ TypeCoercion --------------// Scalar conversion across drivers
 â”œâ”€â”€ PojoMapper ----------------// Reflection & record-based object mapping
 â”œâ”€â”€ DbConfig, DbHandle ------// Connection metadata & unified handle
 â”œâ”€â”€ RelationalApi, DocumentApi
 â””â”€â”€ UnifiedDB (bootstraps engines via ServiceLoader)

engines/
 â”œâ”€â”€ jooq/
 â”‚    â”œâ”€â”€ JooqRelationalApi
 â”‚    â”œâ”€â”€ JooqSelectQuery
 â”‚    â”œâ”€â”€ JooqConditionEmitter
 â”‚    â””â”€â”€ support/ (JooqSets, JooqStrings, JooqTypes, etc.)
 â”œâ”€â”€ mongo/ (planned)
 â”œâ”€â”€ rethink/ (planned)
 â””â”€â”€ sqlite/ (planned)

## ðŸ§© Fluent Conditions
ChivDBâ€™s condition model is composable, engine-agnostic, and convertible into SQL or BSON as needed.

```java
import static com.millenialsoftwares.chivdb.core.Conditions.*;
import static com.millenialsoftwares.chivdb.core.Fields.*;

var c = and(
    or(eq(string("username"), "Steve"), like(string("username"), "%Alex%")),
    gte(int32("level"), 10),
    arrayContains(string("roles"), "builder")
);
```
This can be rendered to:

-   `WHERE (username = 'Steve' OR username LIKE '%Alex%') AND level >= 10 AND roles @> ARRAY['builder']`  
    _(Postgres)_
    
-   or a corresponding MongoDB `$and`/$`or`/$`regex` pipeline expression.


## ðŸ§¬ Type Coercion & Objectification
ChivDB ships with a reflection-based `PojoMapper` that can map:

-   **Plain records**
    
-   **POJOs with setters**
    
-   **Single-argument constructors** (for scalar wrappers)
    

It integrates deeply with the shared `TypeCoercion` layer to support conversions between Java primitives, numerics, UUIDs, dates, and enums.
```java
var mapper = PojoMapper.builder()
    .ignoreUnknown(true)
    .failOnMissing(false)
    .build();

Player p = mapper.map(Map.of("id", id, "username", "Steve"), Player.class);
```

## ðŸª¶ About the Name

> **Chiv** â€” derived from the Hebrew word _××•×œ×¨_ (_Ular_), meaning â€œpocket knife.â€  
> The project embodies that spirit: a compact, versatile tool for every data workload.
